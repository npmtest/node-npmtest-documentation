{"/home/travis/build/npmtest/node-npmtest-documentation/test.js":"/* istanbul instrument in package npmtest_documentation */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-documentation/lib.npmtest_documentation.js":"/* istanbul instrument in package npmtest_documentation */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_documentation = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_documentation = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-documentation/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-documentation && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_documentation */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_documentation\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_documentation.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_documentation.rollup.js'] =\n            local.assetsDict['/assets.npmtest_documentation.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_documentation.__dirname + '/lib.npmtest_documentation.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/index.js":"'use strict';\n\nvar sort = require('./lib/sort'),\n  nest = require('./lib/nest'),\n  filterAccess = require('./lib/filter_access'),\n  filterJS = require('./lib/filter_js'),\n  dependency = require('./lib/input/dependency'),\n  shallow = require('./lib/input/shallow'),\n  parseJavaScript = require('./lib/parsers/javascript'),\n  polyglot = require('./lib/parsers/polyglot'),\n  github = require('./lib/github'),\n  hierarchy = require('./lib/hierarchy'),\n  inferName = require('./lib/infer/name'),\n  inferKind = require('./lib/infer/kind'),\n  inferParams = require('./lib/infer/params'),\n  inferProperties = require('./lib/infer/properties'),\n  inferMembership = require('./lib/infer/membership'),\n  inferReturn = require('./lib/infer/return'),\n  lint = require('./lib/lint');\n\n/**\n * Build a pipeline of comment handlers.\n * @param {...Function} args - Pipeline elements. Each is a function that accepts\n *  a comment and can return a comment or undefined (to drop that comment).\n * @returns {Function} pipeline\n * @private\n */\nfunction pipeline() {\n  var elements = arguments;\n  return function (comment) {\n    for (var i = 0; comment && i < elements.length; i++) {\n      comment = elements[i](comment);\n    }\n    return comment;\n  }\n}\n\n/**\n * A comment handler that returns the comment unchanged.\n * @param {Object} comment parsed comment\n * @returns {Object} comment\n * @private\n */\nfunction noop(comment) {\n  return comment;\n}\n\n/**\n * Generate JavaScript documentation as a list of parsed JSDoc\n * comments, given a root file as a path.\n *\n * @name documentation\n * @param {Array<string>|string} indexes files to process\n * @param {Object} options options\n * @param {Array<string>} options.external a string regex / glob match pattern\n * that defines what external modules will be whitelisted and included in the\n * generated documentation.\n * @param {Array<string>} options.transform source transforms given as strings\n * passed to [the module-deps transform option](https://github.com/substack/module-deps)\n * @param {boolean} [options.polyglot=false] parse comments with a regex rather than\n * a proper parser. This enables support of non-JavaScript languages but\n * reduces documentation's ability to infer structure of code.\n * @param {boolean} [options.shallow=false] whether to avoid dependency parsing\n * even in JavaScript code. With the polyglot option set, this has no effect.\n * @param {Array<string|Object>} [options.order=[]] optional array that\n * defines sorting order of documentation\n * @param {Function} callback to be called when the documentation generation\n * is complete, with (err, result) argumentsj\n * @returns {undefined} calls callback\n */\nmodule.exports = function (indexes, options, callback) {\n  options = options || {};\n\n  if (typeof indexes === 'string') {\n    indexes = [indexes];\n  }\n\n  var inputFn = (options.polyglot || options.shallow) ? shallow : dependency;\n  var parseFn = (options.polyglot) ? polyglot : parseJavaScript;\n\n  return inputFn(indexes, options, function (error, inputs) {\n    if (error) {\n      return callback(error);\n    }\n    try {\n      callback(null,\n        filterAccess(\n          (options.private || options.lint) ? [] : undefined,\n          hierarchy(\n            inputs\n              .filter(filterJS)\n              .reduce(function (memo, file) {\n                return memo.concat(parseFn(file));\n              }, [])\n              .map(pipeline(\n                lint.lint,\n                inferName(),\n                inferKind(),\n                inferParams(),\n                inferProperties(),\n                inferReturn(),\n                inferMembership(),\n                nest,\n                options.github ? github : noop\n              ))\n              .filter(Boolean)\n              .sort(sort.bind(undefined, options.order)))));\n    } catch (e) {\n      callback(e);\n    }\n  });\n};\n\nmodule.exports.formats = {\n  html: require('./lib/output/html'),\n  md: require('./lib/output/markdown'),\n  json: require('./lib/output/json')\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/sort.js":"'use strict';\n\n/**\n * Given a comment, get its sorting key: this is either the comment's\n * name tag, or a hardcoded sorting index given by a user-provided\n * `order` array.\n *\n * @param {Object} comment parsed documentation object\n * @param {Array<string>} [order=[]] an optional list of namepaths\n * @returns {string} sortable key\n * @private\n */\nfunction getSortKey(comment, order) {\n  var key = comment.name || comment.context.file;\n\n  if (order && order.indexOf(key) !== -1) {\n    return order.indexOf(key);\n  }\n\n  return key;\n}\n\n/**\n * Sort two documentation objects, given an optional order object. Returns\n * a numeric sorting value that is compatible with stream-sort.\n *\n * @param {Array<string>} order an array of namepaths that will be sorted\n * in the order given.\n * @param {Object} a documentation object\n * @param {Object} b documentation object\n * @return {number} sorting value\n * @private\n */\nmodule.exports = function sortDocs(order, a, b) {\n  a = getSortKey(a, order);\n  b = getSortKey(b, order);\n\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a - b;\n  }\n  if (typeof a === 'number') {\n    return -1;\n  }\n  if (typeof b === 'number') {\n    return 1;\n  }\n\n  return a.localeCompare(b);\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/nest.js":"'use strict';\n\nfunction nestTag(comment, tagName, target) {\n  if (!comment[target]) {\n    return comment;\n  }\n\n  var result = [],\n    index = {};\n\n  comment[target].forEach(function (tag) {\n    index[tag.name] = tag;\n    var parts = tag.name.split(/(\\[\\])?\\./)\n      .filter(function (part) {\n        return part && part !== '[]';\n      });\n    if (parts.length > 1) {\n      var parent = index[parts.slice(0, -1).join('.')];\n      if (parent === undefined) {\n        comment.errors.push({\n          message: '@' + tagName + ' ' + tag.name + '\\'s parent ' + parts[0] + ' not found',\n          commentLineNumber: tag.lineNumber\n        });\n        result.push(tag);\n        return;\n      }\n      parent.properties = parent.properties || [];\n      parent.properties.push(tag);\n    } else {\n      result.push(tag);\n    }\n  });\n\n  comment[target] = result;\n\n  return comment;\n}\n\n/**\n * Nests\n * [parameters with properties](http://usejsdoc.org/tags-param.html#parameters-with-properties).\n *\n * A parameter `employee.name` will be attached to the parent parameter `employee` in\n * a `properties` array.\n *\n * This assumes that incoming comments have been flattened.\n *\n * @param {Object} comment input comment\n * @return {Object} nested comment\n */\nfunction nest(comment) {\n  return nestTag(nestTag(comment, 'param', 'params'),\n    'property', 'properties');\n}\n\nmodule.exports = nest;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/filter_access.js":"'use strict';\n\nvar walk = require('./walk');\n\n/**\n * Exclude given access levels from the generated documentation: this allows\n * users to write documentation for non-public members by using the\n * `@private` tag.\n *\n * @public\n * @param {Array<string>} [levels=['private']] excluded access levels.\n * @param {Array<Object>} comments parsed comments (can be nested)\n * @return {Array<Object>} filtered comments\n */\nfunction filterAccess(levels, comments) {\n  levels = levels || ['private'];\n\n  function filter(comment) {\n    return levels.indexOf(comment.access) === -1;\n  }\n\n  function recurse(comment) {\n    for (var scope in comment.members) {\n      comment.members[scope] = comment.members[scope].filter(filter);\n    }\n  }\n\n  return walk(comments.filter(filter), recurse);\n}\n\nmodule.exports = filterAccess;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/walk.js":"/**\n * Apply a function to all comments within a hierarchy: this iterates\n * through children in the 'members' property.\n *\n * @param {Array<Object>} comments an array of nested comments\n * @param {Function} fn a walker function\n * @returns {Array<Object>} comments\n */\nfunction walk(comments, fn) {\n  comments.forEach(function (comment) {\n    fn(comment);\n    for (var scope in comment.members) {\n      walk(comment.members[scope], fn);\n    }\n  });\n  return comments;\n}\n\nmodule.exports = walk;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/filter_js.js":"'use strict';\n\n/**\n * Node & browserify support requiring JSON files. JSON files can't be documented\n * with JSDoc or parsed with espree, so we filter them out before\n * they reach documentation's machinery.\n *\n * @public\n * @param {Object} data a file as an object with 'file' property\n * @return {boolean} whether the file is json\n */\nfunction filterJS(data) {\n  return !data.file.match(/\\.json$/);\n}\n\nmodule.exports = filterJS;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/input/dependency.js":"'use strict';\n\nvar mdeps = require('module-deps'),\n  fs = require('fs'),\n  path = require('path'),\n  babelify = require('babelify'),\n  concat = require('concat-stream'),\n  moduleFilters = require('../../lib/module_filters');\n\n/**\n * Returns a readable stream of dependencies, given an array of entry\n * points and an object of options to provide to module-deps.\n *\n * This stream requires filesystem access, and thus isn't suitable\n * for a browser environment.\n *\n * @param {Array<string>} indexes paths to entry files as strings\n * @param {Object} options optional options passed\n * @param {Function} callback called with (err, inputs)\n * @returns {undefined} calls callback\n */\nfunction dependencyStream(indexes, options, callback) {\n  var md = mdeps({\n    filter: function (id) {\n      return !!options.external || moduleFilters.internalOnly(id);\n    },\n    transform: [babelify.configure({\n      sourceMap: false,\n      stage: 0\n    })],\n    postFilter: moduleFilters.externals(indexes, options)\n  });\n  indexes.forEach(function (index) {\n    md.write(path.resolve(index));\n  });\n  md.end();\n  md.once('error', function (error) {\n    return callback(error);\n  });\n  md.pipe(concat(function (inputs) {\n    callback(null, inputs.map(function (input) {\n      // un-transform babelify transformed source\n      input.source = fs.readFileSync(input.file, 'utf8');\n      return input\n    }));\n  }));\n}\n\nmodule.exports = dependencyStream;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/module_filters.js":"'use strict';\nvar path = require('path');\nvar micromatch = require('micromatch');\n\n// Skip external modules. Based on http://git.io/pzPO.\nvar internalModuleRegexp = process.platform === 'win32' ?\n  /* istanbul ignore next */\n  /^(\\.|\\w:)/ :\n  /^[\\/.]/;\n\nmodule.exports = {\n  internalOnly: internalModuleRegexp.test.bind(internalModuleRegexp),\n\n  /**\n   * Create a filter function for use with module-deps, allowing the specified\n   * external modules through.\n   *\n   * @param {Array<string>} indexes - the list of entry points that will be\n   * used by module-deps\n   * @param {Object} options - An options object with `external` being a\n   * micromatch-compaitible glob. *NOTE:* the glob will be matched relative to\n   * the top-level node_modules directory for each entry point.\n   * @return {function} - A function for use as the module-deps `postFilter`\n   * options.\n   */\n  externals: function externalModuleFilter(indexes, options) {\n    var externalFilters = false;\n    if (options.external) {\n      var test = micromatch.matcher(options.external);\n      externalFilters = indexes.map(function (index) {\n        // grab the path of the top-level node_modules directory.\n        var topNodeModules = path.join(path.dirname(index), 'node_modules');\n        return function matchGlob(file, pkg) {\n          // if a module is not found, don't include it.\n          if (!file || !pkg) {\n            return false;\n          }\n          // if package.json specifies a 'main' script, strip that path off\n          // the file to get the module's directory.\n          // otherwise, just use the dirname of the file.\n          if (pkg.main) {\n            file = file.slice(0, -path.normalize(pkg.main).length);\n          } else {\n            file = path.dirname(file);\n          }\n          // test the path relative to the top node_modules dir.\n          var p = path.relative(topNodeModules, file);\n          return test(p);\n        };\n      });\n    }\n\n    return function (id, file, pkg) {\n      var internal = internalModuleRegexp.test(id);\n      return internal || (externalFilters &&\n        externalFilters\n        .some(function (f) {\n          return f(file, pkg);\n        }));\n    };\n  }\n};\n\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/input/shallow.js":"'use strict';\n\nvar fs = require('fs');\n\n/**\n * A readable source for content that doesn't do dependency resolution, but\n * simply reads files and pushes them onto a stream.\n *\n * If an array of strings is provided as input to this method, then\n * they will be treated as filenames and read into the stream.\n *\n * If an array of objects is provided, then we assume that they are valid\n * objects with `source` and `file` properties, and don't use the filesystem\n * at all. This is one way of getting documentation.js to run in a browser\n * or without fs access.\n *\n * @param {Array<string|Object>} indexes entry points\n * @param {Object} options parsing options\n * @param {Function} callback called with (err, inputs)\n * @return {undefined} calls callback\n */\nmodule.exports = function (indexes, options, callback) {\n  return callback(null, indexes.map(function (index) {\n    if (typeof index === 'string') {\n      return {\n        source: fs.readFileSync(index, 'utf8'),\n        file: index\n      };\n    }\n    return index;\n  }));\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/parsers/javascript.js":"'use strict';\n\nvar babel = require('babel-core'),\n  types = require('ast-types'),\n  extend = require('extend'),\n  isJSDocComment = require('../../lib/is_jsdoc_comment'),\n  parse = require('../../lib/parse');\n\n/**\n * Receives a module-dep item,\n * reads the file, parses the JavaScript, and parses the JSDoc.\n *\n * @param {Object} data a chunk of data provided by module-deps\n * @return {Array<Object>} an array of parsed comments\n */\nfunction parseJavaScript(data) {\n  var results = [];\n  var ast = babel.parse(data.source, {\n    code: false,\n    stage: 0,\n    locations: true,\n    ranges: true\n  });\n\n  var visited = {};\n\n  function walkComments(ast, type, includeContext) {\n    types.visit(ast, {\n      visitNode: function (path) {\n        /**\n         * Parse a comment with doctrine and decorate the result with file position and code context.\n         *\n         * @param {Object} comment the current state of the parsed JSDoc comment\n         * @return {undefined} this emits data\n         */\n        function parseComment(comment) {\n          var context = {\n            loc: extend({}, path.value.loc),\n            file: data.file\n          };\n          // Avoid visiting the same comment twice as a leading\n          // and trailing node\n          var key = JSON.stringify(comment.loc);\n          if (!visited[key]) {\n            visited[key] = true;\n            if (includeContext) {\n              // This is non-enumerable so that it doesn't get stringified in\n              // output; e.g. by the documentation binary.\n              Object.defineProperty(context, 'ast', {\n                enumerable: false,\n                value: path\n              });\n\n              if (path.parent && path.parent.node) {\n                context.code = data.source.substring\n                  .apply(data.source, path.parent.node.range);\n              }\n            } else {\n              // Avoid the invariant of a comment with no AST by providing\n              // an empty one.\n              Object.defineProperty(context, 'ast', {\n                enumerable: false,\n                value: {}\n              });\n            }\n            results.push(parse(comment.value, comment.loc, context));\n          }\n        }\n\n        (path.value[type] || [])\n          .filter(isJSDocComment)\n          .forEach(parseComment);\n\n        this.traverse(path);\n      }\n    });\n  }\n\n  walkComments(ast, 'leadingComments', true);\n  walkComments(ast, 'innerComments', false);\n  walkComments(ast, 'trailingComments', false);\n\n  return results;\n}\n\nmodule.exports = parseJavaScript;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/is_jsdoc_comment.js":"'use strict';\n\n/**\n * Detect whether a comment is a JSDoc comment: it must be a block\n * comment which starts with two asterisks, not any other number of asterisks.\n *\n * The code parser automatically strips out the first asterisk that's\n * required for the comment to be a comment at all, so we count the remaining\n * comments.\n *\n * @name isJSDocComment\n * @param {Object} comment an ast-types node of the comment\n * @return {boolean} whether it is valid\n */\nmodule.exports = function isJSDocComment(comment) {\n  var asterisks = comment.value.match(/^(\\*+)/);\n  return (comment.type === 'CommentBlock' || // estree\n    comment.type === 'Block') // get-comments / traditional\n    && asterisks && asterisks[ 1 ].length === 1;\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/parse.js":"'use strict';\n\nvar doctrine = require('doctrine'),\n  flatten = require('./flatten'),\n  normalize = require('./normalize');\n\n/**\n * Parse a comment with doctrine, decorate the result with file position and code\n * context, handle parsing errors, and fix up various infelicities in the structure\n * outputted by doctrine.\n *\n * @param {string} comment input to be parsed\n * @param {Object} loc location of the input\n * @param {Object} context code context of the input\n * @return {Object} an object conforming to the\n * [documentation JSON API](https://github.com/documentationjs/api-json) schema\n */\nfunction parseJSDoc(comment, loc, context) {\n  var result = doctrine.parse(comment, {\n    // have doctrine itself remove the comment asterisks from content\n    unwrap: true,\n    // enable parsing of optional parameters in brackets, JSDoc3 style\n    sloppy: true,\n    // `recoverable: true` is the only way to get error information out\n    recoverable: true,\n    // include line numbers\n    lineNumbers: true\n  });\n\n  result.loc = loc;\n  result.context = context;\n  result.errors = [];\n\n  var i = 0;\n  while (i < result.tags.length) {\n    var tag = result.tags[i];\n    if (tag.errors) {\n      for (var j = 0; j < tag.errors.length; j++) {\n        result.errors.push(tag.errors[j]);\n      }\n      result.tags.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  return flatten(normalize(result));\n}\n\nmodule.exports = parseJSDoc;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/flatten.js":"'use strict';\n\nvar extend = require('extend');\n\nfunction flattenName(result, tag) {\n  result[tag.title] = tag.name;\n}\n\nfunction flattenDescription(result, tag) {\n  result[tag.title] = tag.description;\n}\n\nfunction flattenTypedName(result, tag) {\n  result[tag.title] = {\n    name: tag.name\n  };\n\n  if (tag.type) {\n    result[tag.title].type = tag.type;\n  }\n}\n\nvar flatteners = {\n  'name': flattenName,\n  'function': flattenName,\n  'mixin': flattenName,\n  'memberof': flattenDescription,\n  'classdesc': flattenDescription,\n  'lends': flattenDescription,\n  'event': flattenDescription,\n  'external': flattenDescription,\n  'file': flattenDescription,\n  'callback': flattenDescription,\n  'class': flattenTypedName,\n  'constant': flattenTypedName,\n  'member': flattenTypedName,\n  'module': flattenTypedName,\n  'namespace': flattenTypedName,\n  'typedef': flattenTypedName,\n  'kind': function (result, tag) {\n    result.kind = tag.kind;\n  },\n  'property': function (result, tag) {\n    if (!result.properties) {\n      result.properties = [];\n    }\n    result.properties.push(tag);\n  },\n  'param': function (result, tag) {\n    if (!result.params) {\n      result.params = [];\n    }\n    result.params.push(tag);\n  },\n  'throws': function (result, tag) {\n    if (!result.throws) {\n      result.throws = [];\n    }\n    result.throws.push(tag);\n  },\n  'returns': function (result, tag) {\n    if (!result.returns) {\n      result.returns = [];\n    }\n    result.returns.push(tag);\n  },\n  'augments': function (result, tag) {\n    if (!result.augments) {\n      result.augments = [];\n    }\n    result.augments.push(tag);\n  },\n  'example': function (result, tag) {\n    if (!result.examples) {\n      result.examples = [];\n    }\n    result.examples.push(tag.description);\n  },\n  'global': function (result) {\n    result.scope = 'global';\n  },\n  'static': function (result) {\n    result.scope = 'static';\n  },\n  'instance': function (result) {\n    result.scope = 'instance';\n  },\n  'inner': function (result) {\n    result.scope = 'inner';\n  },\n  'access': function (result, tag) {\n    result.access = tag.access;\n  },\n  'public': function (result) {\n    result.access = 'public';\n  },\n  'protected': function (result) {\n    result.access = 'protected';\n  },\n  'private': function (result) {\n    result.access = 'private';\n  }\n};\n\n/**\n * Flattens tags in an opinionated way.\n *\n * The following tags are assumed to be singletons, and are flattened\n * to a top-level property on the result whose value is extracted from\n * the tag:\n *\n *  * `@name`\n *  * `@memberof`\n *  * `@classdesc`\n *  * `@kind`\n *  * `@class`\n *  * `@constant`\n *  * `@event`\n *  * `@external`\n *  * `@file`\n *  * `@function`\n *  * `@member`\n *  * `@mixin`\n *  * `@module`\n *  * `@namespace`\n *  * `@typedef`\n *  * `@access`\n *  * `@lends`\n *\n * The following tags are flattened to a top-level array-valued property:\n *\n *  * `@param` (to `params` property)\n *  * `@property` (to `properties` property)\n *  * `@returns` (to `returns` property)\n *  * `@augments` (to `augments` property)\n *  * `@example` (to `examples` property)\n *  * `@throws` (to `throws` property)\n *\n * The `@global`, `@static`, `@instance`, and `@inner` tags are flattened\n * to a `scope` property whose value is `\"global\"`, `\"static\"`, `\"instance\"`,\n * or `\"inner\"`.\n *\n * The `@access`, `@public`, `@protected`, and `@private` tags are flattened\n * to an `access` property whose value is `\"protected\"` or `\"private\"`.\n * The assumed default value is `\"public\"`, so `@access public` or `@public`\n * tags result in no `access` property.\n *\n * @name flatten\n * @param {Object} comment a parsed comment\n * @return {Object} comment with tags flattened\n */\nmodule.exports = function (comment) {\n  var result = extend({}, comment);\n\n  comment.tags.forEach(function (tag) {\n    (flatteners[tag.title] || function () {})(result, tag);\n  });\n\n  return result;\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/normalize.js":"'use strict';\n\nvar extend = require('extend');\n\n/**\n * Normalizes synonymous tags to the canonical tag type listed on http://usejsdoc.org/.\n *\n * For example, given the input object:\n *\n *     { tags: [\n *       { title: \"virtual\" },\n *       { title: \"return\", ... }\n *     ]}\n *\n * The output object will be:\n *\n *     { tags: [\n *       { title: \"abstract\" },\n *       { title: \"returns\", ... }\n *     ]}\n *\n * The following synonyms are normalized:\n *\n *  * virtual -> abstract\n *  * extends -> augments\n *  * constructor -> class\n *  * const -> constant\n *  * defaultvalue -> default\n *  * desc -> description\n *  * host -> external\n *  * fileoverview, overview -> file\n *  * emits -> fires\n *  * func, method -> function\n *  * var -> member\n *  * arg, argument -> param\n *  * prop -> property\n *  * return -> returns\n *  * exception -> throws\n *  * linkcode, linkplain -> link\n *\n * @name normalize\n * @param {Object} comment parsed comment\n * @return {Object} comment with normalized properties\n */\nmodule.exports = function (comment) {\n  return extend({}, comment, {\n    tags: comment.tags.map(normalize)\n  });\n};\n\nvar synonyms = {\n  'virtual': 'abstract',\n  'extends': 'augments',\n  'constructor': 'class',\n  'const': 'constant',\n  'defaultvalue': 'default',\n  'desc': 'description',\n  'host': 'external',\n  'fileoverview': 'file',\n  'overview': 'file',\n  'emits': 'fires',\n  'func': 'function',\n  'method': 'function',\n  'var': 'member',\n  'arg': 'param',\n  'argument': 'param',\n  'prop': 'property',\n  'return': 'returns',\n  'exception': 'throws',\n  'linkcode': 'link',\n  'linkplain': 'link'\n};\n\nfunction normalize(tag) {\n  var canonical = synonyms[tag.title];\n  return canonical ? extend({}, tag, { title: canonical }) : tag;\n}\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/parsers/polyglot.js":"'use strict';\n\nvar getComments = require('get-comments'),\n  extend = require('extend'),\n  isJSDocComment = require('../../lib/is_jsdoc_comment'),\n  parse = require('../../lib/parse');\n\n/**\n * Documentation stream parser: this receives a module-dep item,\n * reads the file, parses the JavaScript, parses the JSDoc, and\n * emits parsed comments.\n * @param {Object} data a chunk of data provided by module-deps\n * @return {Array<Object>} adds to memo\n */\nfunction parsePolyglot(data) {\n  return getComments(data.source, true)\n    .filter(isJSDocComment)\n    .map(function (comment) {\n      var context = {\n        loc: extend({}, comment.loc),\n        file: data.file\n      };\n      return parse(comment.value, comment.loc, context);\n    });\n}\n\nmodule.exports = parsePolyglot;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/github.js":"'use strict';\n\nvar path = require('path');\nvar findGit = require('../lib/git/find_git');\nvar getGithubURLPrefix = require('../lib/git/url_prefix');\n\nfunction getFileRoot(file) {\n  return path.dirname(findGit(file));\n}\n\n/**\n * Attempts to link code to its place on GitHub.\n *\n * @name linkGitHub\n * @param {Object} comment parsed comment\n * @return {Object} comment with github inferred\n */\nmodule.exports = function (comment) {\n  var root = getFileRoot(comment.context.file);\n  var urlPrefix = getGithubURLPrefix(root);\n  comment.context.path = comment.context.file.replace(root + '/', '');\n  comment.context.github = urlPrefix +\n    comment.context.file.replace(root + '/', '') +\n    '#L' + comment.context.loc.start.line + '-' +\n    'L' + comment.context.loc.end.line;\n  return comment;\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/git/find_git.js":"'use strict';\n\nvar path = require('path');\nvar fs = require('fs');\n\n/**\n * Given a full path to a single file, iterate upwards through the filesystem\n * to find a directory with a .git file indicating that it is a git repository\n * @param {string} filename any file within a repository\n * @returns {string} repository path\n */\nfunction findGit(filename) {\n  var paths = filename.split(path.sep);\n  for (var i = paths.length; i > 0; i--) {\n    var p = path.resolve(paths.slice(0, i).join(path.sep) + path.sep + '.git');\n    if (fs.existsSync(p)) {\n      return p;\n    }\n  }\n}\n\nmodule.exports = findGit;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/git/url_prefix.js":"var fs = require('fs');\nvar path = require('path');\nvar urlFromGit = require('github-url-from-git');\nvar getRemoteOrigin = require('remote-origin-url');\n\n/**\n * Given a a root directory, find its git configuration and figure out\n * the HTTPS URL at the base of that GitHub repository.\n *\n * @param {string} root path at the base of this local repo\n * @returns {string} base HTTPS url of the GitHub repository\n * @throws {Error} if the root is not a git repo\n */\nfunction getGithubURLPrefix(root) {\n  return urlFromGit(getRemoteOrigin.sync(root)) + '/blob/' +\n    fs.readFileSync(path.join(root, '.git',\n      fs.readFileSync(path.join(root, '.git', 'HEAD'), 'utf8')\n        .match(/ref\\: (.*)/)[1]), 'utf8').trim() + '/';\n}\n\nmodule.exports = getGithubURLPrefix;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/hierarchy.js":"'use strict';\n\n/**\n * @param {Array<Object>} comments an array of parsed comments\n * @returns {Array<Object>} nested comments, with only root comments\n * at the top level.\n */\nmodule.exports = function (comments) {\n  var id = 0,\n    root = {\n      members: {\n        instance: {},\n        static: {}\n      }\n    };\n\n  comments.forEach(function (comment) {\n    var path = [];\n\n    if (comment.memberof) {\n      // TODO: full namepath parsing\n      path = comment.memberof\n        .split('.')\n        .map(function (segment) {\n          return ['static', segment];\n        });\n    }\n\n    if (!comment.name) {\n      comment.errors.push({\n        message: 'could not determine @name for hierarchy'\n      });\n    }\n\n    path.push([\n      comment.scope || 'static',\n      comment.name || ('unknown_' + id++)\n    ]);\n\n    var node = root;\n\n    while (path.length) {\n      var segment = path.shift(),\n        scope = segment[0],\n        name = segment[1];\n\n      if (!node.members[scope].hasOwnProperty(name)) {\n        node.members[scope][name] = {\n          comments: [],\n          members: {\n            instance: {},\n            static: {}\n          }\n        };\n      }\n\n      node = node.members[scope][name];\n    }\n\n    node.comments.push(comment);\n  });\n\n  /*\n   * Massage the hierarchy into a format more suitable for downstream consumers:\n   *\n   * * Individual top-level scopes are collapsed to a single array\n   * * Members at intermediate nodes are copied over to the corresponding comments,\n   *   with multisignature comments allowed.\n   * * Intermediate nodes without corresponding comments indicate an undefined\n   *   @memberof reference. Emit an error, and reparent the offending comment to\n   *   the root.\n   * * Add paths to each comment, making it possible to generate permalinks\n   *   that differentiate between instance functions with the same name but\n   *   different `@memberof` values.\n   *\n   *     Person#say  // the instance method named \"say.\"\n   *     Person.say  // the static method named \"say.\"\n   *     Person~say  // the inner method named \"say.\"\n   */\n  function toComments(nodes, root, hasUndefinedParent, path) {\n    var result = [], scope;\n\n    path = path || [];\n\n    for (var name in nodes) {\n      var node = nodes[name];\n\n      for (scope in node.members) {\n        node.members[scope] = toComments(node.members[scope], root || result,\n          !node.comments.length,\n          node.comments.length ? path.concat(node.comments[0]) : []);\n      }\n\n      for (var i = 0; i < node.comments.length; i++) {\n        var comment = node.comments[i];\n\n        comment.members = {};\n        for (scope in node.members) {\n          comment.members[scope] = node.members[scope];\n        }\n\n        comment.path = path.map(function (n) {\n          return n.name;\n        }).concat(comment.name);\n\n        if (hasUndefinedParent) {\n          var memberOfTag = comment.tags.filter(function (tag) {\n            return tag.title === 'memberof'\n          })[0];\n          var memberOfTagLineNumber = (memberOfTag && memberOfTag.lineNumber) || 0;\n\n          comment.errors.push({\n            message: '@memberof reference to ' + comment.memberof + ' not found',\n            commentLineNumber: memberOfTagLineNumber\n          });\n\n          root.push(comment);\n        } else {\n          result.push(comment);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  return toComments(root.members.static);\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/infer/name.js":"'use strict';\n\nvar types = require('ast-types'),\n  pathParse = require('parse-filepath');\n\n/**\n * Infers a `name` tag from the context,\n * and adopt `@class` and other other tags as implied name tags.\n *\n * @name inferName\n * @param {Object} comment parsed comment\n * @returns {Object} comment with name inferred\n */\nmodule.exports = function () {\n  return function inferName(comment) {\n    // If this comment is already explicitly named, simply pass it\n    // through without doing any inference.\n    if (comment.name) {\n      return comment;\n    }\n\n    if (comment.event) {\n      comment.name = comment.event;\n      return comment;\n    }\n\n    if (comment.callback) {\n      comment.name = comment.callback;\n      return comment;\n    }\n\n    if (comment.class && comment.class.name) {\n      comment.name = comment.class.name;\n      return comment;\n    }\n\n    if (comment.module) {\n      comment.name = comment.module.name || pathParse(comment.context.file).name;\n      return comment;\n    }\n\n    if (comment.typedef) {\n      comment.name = comment.typedef.name;\n      return comment;\n    }\n\n    // The strategy here is to do a depth-first traversal of the AST,\n    // looking for nodes with a \"name\" property, with exceptions as needed.\n    // For example, name inference for a MemberExpression `foo.bar = baz` will\n    // infer the named based on the `property` of the MemberExpression (`bar`)\n    // rather than the `object` (`foo`).\n    types.visit(comment.context.ast, {\n      inferName: function (path, value) {\n        if (value && value.name) {\n          comment.name = value.name;\n          this.abort();\n        } else {\n          this.traverse(path);\n        }\n      },\n\n      visitNode: function (path) {\n        this.inferName(path, path.value);\n      },\n\n      visitMemberExpression: function (path) {\n        this.inferName(path, path.value.property);\n      }\n    });\n\n    return comment;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/infer/kind.js":"'use strict';\n\nvar types = require('ast-types');\n\nvar kindShorthands = ['class', 'constant', 'event', 'external', 'file',\n  'function', 'member', 'mixin', 'module', 'namespace', 'typedef'];\n\n/**\n * Infers a `kind` tag from other tags or from the context.\n *\n * @name inferKind\n * @param {Object} comment parsed comment\n * @returns {Object} comment with kind inferred\n */\nmodule.exports = function () {\n  return function inferKind(comment) {\n    if (comment.kind) {\n      return comment;\n    }\n\n    for (var i = 0; i < kindShorthands.length; i++) {\n      var kind = kindShorthands[i];\n      if (kind in comment) {\n        comment.kind = kind;\n        // only allow a comment to have one kind\n        return comment;\n      }\n    }\n\n    types.visit(comment.context.ast, {\n      visitClassDeclaration: function () {\n        comment.kind = 'class';\n        this.abort();\n      },\n      visitFunction: function (path) {\n        if (path.value && path.value.id && path.value.id.name && !!/^[A-Z]/.exec(path.value.id.name)) {\n          comment.kind = 'class';\n          this.abort();\n        } else {\n          comment.kind = 'function';\n          this.abort();\n        }\n      },\n      visitTypeAlias: function () {\n        comment.kind = 'typedef';\n        this.abort();\n      },\n      visitVariableDeclaration: function (path) {\n        if (path.value.kind === 'const') {\n          comment.kind = 'constant';\n          this.abort();\n        } else {\n          this.traverse(path);\n        }\n      }\n    });\n\n    return comment;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/infer/params.js":"'use strict';\n\nvar types = require('ast-types'),\n  extend = require('extend'),\n  flowDoctrine = require('../flow_doctrine');\n\n\n/**\n * Infers param tags by reading function parameter names\n *\n * @name inferParams\n * @param {Object} comment parsed comment\n * @returns {Object} comment with parameters\n */\nmodule.exports = function () {\n  return function inferParams(comment) {\n\n    /**\n     * Given a parameter like\n     *\n     *     function a(b = 1)\n     *\n     * Format it as an optional parameter in JSDoc land\n     *\n     * @param {Object} param ESTree node\n     * @returns {Object} JSDoc param\n     */\n    function paramWithDefaultToDoc(param) {\n      var newParam = paramToDoc(param.left);\n      var optionalParam = {\n        title: 'param',\n        name: newParam.name,\n        'default': comment.context.code.substring(\n          param.right.start, param.right.end)\n      };\n\n      if (newParam.type) {\n        optionalParam.type = {\n          type: 'OptionalType',\n          expression: newParam.type\n        };\n      }\n\n      return optionalParam;\n    }\n\n    function destructuringPropertyToDoc(i, property) {\n      return paramToDoc(extend({}, property, {\n        name: '$' + i + '.' + property.key.name\n      }));\n    }\n\n    function destructuringParamToDoc(param, i) {\n      return [{\n        title: 'param',\n        name: '$' + i,\n        type: flowDoctrine(param)\n      }].concat(param.properties.map(destructuringPropertyToDoc.bind(null, i)));\n    }\n\n    function restParamToDoc(param) {\n      var newParam = {\n        title: 'param',\n        name: param.argument.name,\n        lineNumber: param.loc.start.name,\n        type: {\n          type: 'RestType'\n        }\n      };\n      if (param.typeAnnotation) {\n        newParam.type.expression = flowDoctrine(param.typeAnnotation.typeAnnotation);\n      }\n      return newParam;\n    }\n\n    function paramToDoc(param, i) {\n      // ES6 default\n      if (param.type === 'AssignmentPattern') {\n        return paramWithDefaultToDoc(param);\n      }\n\n      if (param.type === 'ObjectPattern') {\n        return destructuringParamToDoc(param, i);\n      }\n\n      if (param.type === 'RestElement') {\n        return restParamToDoc(param);\n      }\n\n      var newParam = {\n        title: 'param',\n        name: param.name,\n        lineNumber: param.loc.start.line\n      };\n\n      // Flow/TS annotations\n      if (param.typeAnnotation && param.typeAnnotation.typeAnnotation) {\n        newParam.type = flowDoctrine(param.typeAnnotation.typeAnnotation);\n      }\n\n      return newParam;\n    }\n\n    function abort() {\n      return false\n    }\n\n    types.visit(comment.context.ast, {\n      visitCallExpression: abort,\n      visitFunction: function (path) {\n\n        // Ensure that explicitly specified parameters are not overridden\n        // by inferred parameters\n        var existingParams = (comment.params || []).reduce(function (memo, param) {\n          memo[param.name] = param;\n          return memo;\n        }, {});\n\n        var paramOrder = {};\n        var i = 0;\n\n        path.value.params\n          .map(paramToDoc)\n          .forEach(function (doc) {\n            if (existingParams[doc.name] === undefined) {\n              // This type is not explicitly documented\n              if (!comment.params) {\n                comment.params = [];\n              }\n\n              comment.params = comment.params.concat(doc);\n            } else if (!existingParams[doc.name].type) {\n              // This param has a description, but potentially it can\n              // be have an inferred type. Infer its type without\n              // dropping the description.\n              if (doc.type) {\n                existingParams[doc.name].type = doc.type;\n              }\n            }\n            paramOrder[doc.name] = i++;\n          });\n\n        // Ensure that if params are specified partially or in\n        // the wrong order, they'll be output in the order\n        // they actually appear in code\n        if (comment.params) {\n          comment.params.sort(function (a, b) {\n            return paramOrder[a.name] - paramOrder[b.name];\n          });\n        }\n\n        this.abort();\n      }\n    });\n\n    return comment;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/flow_doctrine.js":"var namedTypes = {\n  'NumberTypeAnnotation': 'number',\n  'BooleanTypeAnnotation': 'boolean',\n  'ObjectTypeAnnotation': 'Object',\n  'StringTypeAnnotation': 'string'\n};\n\nvar oneToOne = {\n  'AnyTypeAnnotation': {\n    type: 'AllLiteral'\n  }\n};\n\nfunction flowDoctrine(type) {\n\n  if (type.type in namedTypes) {\n    return {\n      type: 'NameExpression',\n      name: namedTypes[type.type]\n    };\n  }\n\n  if (type.type in oneToOne) {\n    return oneToOne[type.type];\n  }\n\n  if (type.type === 'NullableTypeAnnotation') {\n    return {\n      type: 'OptionalType',\n      expression: flowDoctrine(type.typeAnnotation)\n    };\n  }\n\n  if (type.type === 'UnionTypeAnnotation') {\n    return {\n      type: 'UnionType',\n      elements: type.types.map(flowDoctrine)\n    };\n  }\n\n  if (type.type === 'GenericTypeAnnotation') {\n\n    if (type.typeParameters) {\n      return {\n        type: 'TypeApplication',\n        expression: {\n          type: 'NameExpression',\n          name: type.id.name\n        },\n        applications: type.typeParameters.params.map(flowDoctrine)\n      };\n    }\n\n    return {\n      type: 'NameExpression',\n      name: type.id.name\n    };\n  }\n}\n\nmodule.exports = flowDoctrine;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/infer/properties.js":"'use strict';\n\nvar types = require('ast-types'),\n  flowDoctrine = require('../flow_doctrine');\n\n\n/**\n * Infers param tags by reading function parameter names\n *\n * @name inferParams\n * @param {Object} comment parsed comment\n * @returns {Object} comment with parameters\n */\nmodule.exports = function () {\n\n  function prefixedName(name, prefix) {\n    if (prefix.length) {\n      return prefix.join('.') + '.' + name;\n    }\n    return name;\n  }\n\n  function propertyToDoc(property, prefix) {\n    var newProperty = {\n      title: 'property',\n      name: prefixedName(property.key.name, prefix),\n      lineNumber: property.loc.start.line,\n      type: flowDoctrine(property.value)\n    };\n    return newProperty;\n  }\n\n  return function inferProperties(comment) {\n\n\n    // Ensure that explicitly specified properties are not overridden\n    // by inferred properties\n    var explicitProperties = (comment.properties || []).reduce(function (memo, property) {\n      memo[property.name] = true;\n      return memo;\n    }, {});\n\n    function inferProperties(value, prefix) {\n      if (value.type === 'ObjectTypeAnnotation') {\n        value.properties.forEach(function (property) {\n          if (explicitProperties[prefixedName(property.key.name, prefix)] === undefined) {\n            if (!comment.properties) {\n              comment.properties = [];\n            }\n            comment.properties = comment.properties.concat(propertyToDoc(property, prefix));\n            // Nested type parameters\n            if (property.value.type === 'ObjectTypeAnnotation') {\n              inferProperties(property.value, prefix.concat(property.key.name));\n            }\n          }\n        });\n      }\n    }\n\n    types.visit(comment.context.ast, {\n      visitTypeAlias: function (path) {\n        inferProperties(path.value.right, []);\n        this.abort();\n      }\n    });\n\n    return comment;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/infer/membership.js":"'use strict';\n\nvar types = require('ast-types'),\n  pathParse = require('parse-filepath'),\n  isJSDocComment = require('../../lib/is_jsdoc_comment'),\n  parse = require('../../lib/parse');\n\nvar n = types.namedTypes;\n\nfunction findLendsIdentifiers(node) {\n  if (!node || !node.leadingComments) {\n    return;\n  }\n\n  for (var i = 0; i < node.leadingComments.length; i++) {\n    var comment = node.leadingComments[i];\n    if (isJSDocComment(comment)) {\n      var lends = parse(comment.value).lends;\n      if (lends) {\n        return lends.split('.');\n      }\n    }\n  }\n}\n\n/**\n * Extract and return the chain of identifiers from the left hand side of expressions\n * of the forms `Foo = ...`, `Foo.bar = ...`, `Foo.bar.baz = ...`, etc.\n *\n * @param {NodePath} path AssignmentExpression, MemberExpression, or Identifier\n * @returns {Array<string>} identifiers\n * @private\n */\nfunction extractIdentifiers(path) {\n  var identifiers = [];\n\n  types.visit(path, {\n    visitNode: function () {\n      return false;\n    },\n\n    visitAssignmentExpression: function (path) {\n      this.traverse(path);\n    },\n\n    visitMemberExpression: function (path) {\n      this.traverse(path);\n    },\n\n    visitIdentifier: function (path) {\n      identifiers.push(path.node.name);\n      return false;\n    }\n  });\n\n  return identifiers;\n}\n\n/**\n * Count leading identifiers that refer to a module export (`exports` or `module.exports`).\n * @param {Object} comment parsed comment\n * @param {Array<string>} identifiers array of identifier names\n * @returns {number} number of identifiers referring to a module export (0, 1 or 2)\n */\nfunction countModuleIdentifiers(comment, identifiers) {\n  if (identifiers.length >= 1 && identifiers[0] === 'exports') {\n    return 1;\n  }\n\n  if (identifiers.length >= 2 && identifiers[0] === 'module' && identifiers[1] === 'exports') {\n    return 2;\n  }\n\n  return 0;\n}\n\n/**\n * Uses code structure to infer `memberof`, `instance`, and `static`\n * tags from the placement of JSDoc\n * annotations within a file\n *\n * @param {Object} comment parsed comment\n * @returns {Object} comment with membership inferred\n */\nmodule.exports = function () {\n  var currentModule;\n\n  function inferModuleName(comment) {\n    return (comment.module && comment.module.name) ||\n      pathParse(comment.context.file).name;\n  }\n\n  /**\n   * Set `memberof` and `instance`/`static` tags on `comment` based on the\n   * array of `identifiers`. If the last element of the `identifiers` is\n   * `\"prototype\"`, it is assumed to be an instance member; otherwise static.\n   * If the `identifiers` start with `exports` or `module.exports`, assign\n   * membership based on the last seen @module tag or name of the current file.\n   *\n   * @param {Object} comment comment for which to infer memberships\n   * @param {Array<string>} identifiers array of identifier names\n   * @param {string} explicitScope if derived from an es6 class, whether or\n   * not this method had the static keyword\n   * @returns {undefined} mutates `comment`\n   * @private\n   */\n  function inferMembershipFromIdentifiers(comment, identifiers, explicitScope) {\n    if (identifiers.length === 1 && identifiers[0] === 'module' && comment.name === 'exports') {\n      comment.name = inferModuleName(currentModule || comment);\n      return;\n    }\n\n    /*\n     * Test whether identifiers start with a module export (`exports` or `module.exports`),\n     * and if so replace those identifiers with the name of the current module.\n     */\n    var moduleIdentifierCount = countModuleIdentifiers(comment, identifiers);\n    if (moduleIdentifierCount) {\n      identifiers = identifiers.slice(moduleIdentifierCount);\n      identifiers.unshift(inferModuleName(currentModule || comment));\n    }\n\n    if (identifiers[identifiers.length - 1] === 'prototype') {\n      comment.memberof = identifiers.slice(0, -1).join('.');\n      comment.scope = 'instance';\n    } else {\n      comment.memberof = identifiers.join('.');\n      if (explicitScope !== undefined) {\n        comment.scope = explicitScope;\n      } else {\n        comment.scope = 'static';\n      }\n    }\n  }\n\n  return function inferMembership(comment) {\n    if (comment.module) {\n      currentModule = comment;\n    }\n\n    if (comment.lends) {\n      return;\n    }\n\n    if (comment.memberof) {\n      return comment;\n    }\n\n    var path = comment.context.ast;\n    var identifiers;\n\n    /*\n     * Deal with an oddity of espree: the jsdoc comment is attached to a different\n     * node in the two expressions `a.b = c` vs `a.b = function () {}`.\n     */\n    if (n.ExpressionStatement.check(path.node) &&\n        n.AssignmentExpression.check(path.node.expression) &&\n        n.MemberExpression.check(path.node.expression.left)) {\n      path = path.get('expression').get('left');\n    }\n\n    /*\n     * Same as above but for `b: c` vs `b: function () {}`.\n     */\n    if (n.Property.check(path.node) &&\n        n.Identifier.check(path.node.key)) {\n      path = path.get('key');\n    }\n\n    // Foo.bar = ...;\n    // Foo.prototype.bar = ...;\n    // Foo.bar.baz = ...;\n    if (n.MemberExpression.check(path.node)) {\n      identifiers = extractIdentifiers(path);\n      if (identifiers.length >= 2) {\n        inferMembershipFromIdentifiers(comment, identifiers.slice(0, -1));\n      }\n    }\n\n    // /** @lends Foo */{ bar: ... }\n    if (n.Identifier.check(path.node) &&\n      n.Property.check(path.parent.node) &&\n      n.ObjectExpression.check(path.parent.parent.node)) {\n      // The @lends comment is sometimes attached to the first property rather than\n      // the object expression itself.\n      identifiers = findLendsIdentifiers(path.parent.parent.node) ||\n          findLendsIdentifiers(path.parent.parent.node.properties[0]);\n      if (identifiers) {\n        inferMembershipFromIdentifiers(comment, identifiers);\n      }\n    }\n\n    // Foo = { bar: ... };\n    // Foo.prototype = { bar: ... };\n    // Foo.bar = { baz: ... };\n    if (n.Identifier.check(path.node) &&\n        n.Property.check(path.parent.node) &&\n        n.ObjectExpression.check(path.parent.parent.node) &&\n        n.AssignmentExpression.check(path.parent.parent.parent.node)) {\n      identifiers = extractIdentifiers(path.parent.parent.parent);\n      if (identifiers.length >= 1) {\n        inferMembershipFromIdentifiers(comment, identifiers);\n      }\n    }\n\n    // var Foo = { bar: ... }\n    if (n.Identifier.check(path.node) &&\n        n.Property.check(path.parent.node) &&\n        n.ObjectExpression.check(path.parent.parent.node) &&\n        n.VariableDeclarator.check(path.parent.parent.parent.node)) {\n      identifiers = [path.parent.parent.parent.node.id.name];\n      inferMembershipFromIdentifiers(comment, identifiers);\n    }\n\n    // class Foo { bar() { } }\n    if (n.MethodDefinition.check(path.node) &&\n        n.ClassBody.check(path.parent.node) &&\n        n.ClassDeclaration.check(path.parent.parent.node)) {\n      identifiers = [path.parent.parent.node.id.name];\n      var scope = 'instance';\n      if (path.node.static == true) {\n        scope = 'static';\n      }\n      inferMembershipFromIdentifiers(comment, identifiers, scope);\n    }\n\n    return comment;\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/infer/return.js":"'use strict';\n\nvar types = require('ast-types'),\n  flowDoctrine = require('../flow_doctrine');\n\n/**\n * Infers returns tags by using Flow return type annotations\n *\n * @name inferReturn\n * @param {Object} comment parsed comment\n * @returns {Object} comment with return tag inferred\n */\nmodule.exports = function () {\n  return function inferReturn(comment) {\n    types.visit(comment.context.ast, {\n      visitFunction: function (path) {\n\n        if (!comment.returns &&\n          path.value.returnType &&\n          path.value.returnType.typeAnnotation) {\n          comment.returns = [{\n            type: flowDoctrine(path.value.returnType.typeAnnotation)\n          }];\n        }\n\n        this.abort();\n      }\n    });\n\n    return comment;\n  };\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/lint.js":"'use strict';\n\nvar VFile = require('vfile'),\n  walk = require('../lib/walk'),\n  parseFilepath = require('parse-filepath'),\n  vfileSort = require('vfile-sort'),\n  reporter = require('vfile-reporter');\n\nvar CANONICAL = {\n  'String': 'string',\n  'Boolean': 'boolean',\n  'Undefined': 'undefined',\n  'Number': 'number',\n  'array': 'Array',\n  'date': 'Date',\n  'object': 'Object'\n};\n\n/**\n * Passively lints and checks documentation data.\n *\n * @name lint\n * @param {Object} comment parsed comment\n * @returns {Array<Object>} array of errors\n */\nfunction lint(comment) {\n  comment.tags.forEach(function (tag) {\n    function nameInvariant(name) {\n      if (CANONICAL[name]) {\n        comment.errors.push({\n          message: 'type ' + name + ' found, ' + CANONICAL[name] + ' is standard',\n          commentLineNumber: tag.lineNumber\n        });\n      }\n    }\n\n    function checkCanonical(type) {\n      if (type.type === 'NameExpression') {\n        nameInvariant(type.name);\n      } else if (type.type === 'UnionType') {\n        type.elements.forEach(checkCanonical);\n      } else if (type.type === 'OptionalType') {\n        checkCanonical(type.expression);\n      } else if (type.type === 'TypeApplication') {\n        checkCanonical(type.expression);\n        type.applications.map(checkCanonical);\n      }\n    }\n\n    if (tag.title === 'param' && tag.type) {\n      checkCanonical(tag.type);\n    }\n  });\n  return comment;\n}\n\nfunction format(comments) {\n  var vFiles = {};\n  walk(comments, function (comment) {\n    comment.errors.forEach(function (error) {\n      var p = comment.context.file;\n      var parts = parseFilepath(p);\n      vFiles[p] = vFiles[p] || new VFile({\n        directory: parts.dirname,\n        filename: parts.basename\n      });\n      vFiles[p].warn(error.message, {\n        line: comment.loc.start.line + error.commentLineNumber || 0\n      });\n    });\n  });\n  return reporter(Object.keys(vFiles).map(function (p) {\n    return vfileSort(vFiles[p]);\n  }));\n}\n\nmodule.exports.lint = lint;\nmodule.exports.format = format;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/output/html.js":"'use strict';\n\nvar File = require('vinyl'),\n  vfs = require('vinyl-fs'),\n  concat = require('concat-stream'),\n  Handlebars = require('handlebars'),\n  walk = require('../walk'),\n  getTemplate = require('../get_template'),\n  resolveTheme = require('../resolve_theme'),\n  helpers = require('../html_helpers'),\n  hljs = require('highlight.js');\n\n/**\n * Given a string of JavaScript, return a string of HTML representing\n * that JavaScript highlighted.\n *\n * @param {string} example string of javascript\n * @returns {string} highlighted html\n */\nfunction highlightString(example) {\n  return hljs.highlight('js', example).value;\n}\n\n/**\n * Highlights the contents of the `example` tag.\n *\n * @name highlight\n * @param {Object} comment parsed comment\n * @return {Object} comment with highlighted code\n */\nfunction highlight(comment) {\n  if (comment.examples) {\n    comment.examples = comment.examples.map(highlightString);\n  }\n  return comment;\n}\n\n/**\n * Formats documentation as HTML.\n *\n * @param {Array<Object>} comments parsed comments\n * @param {Object} options Options that can customize the output\n * @param {string} [options.theme] Name of a module used for an HTML theme.\n * @param {Function} callback called with array of results as vinyl-fs objects\n * @returns {undefined} calls callback\n * @name html\n */\nmodule.exports = function makeHTML(comments, options, callback) {\n  comments = walk(comments, highlight);\n\n  options = options || {};\n\n  var themeModule = resolveTheme(options.theme);\n  var pageTemplate = getTemplate(Handlebars, themeModule, 'index.hbs');\n\n  Handlebars.registerPartial('section',\n    getTemplate(Handlebars, themeModule, 'section.hbs'));\n\n  var paths = comments.map(function (comment) {\n    return comment.path.join('.');\n  }).filter(function (path) {\n    return path;\n  });\n\n  helpers(Handlebars, paths);\n\n  // push assets into the pipeline as well.\n  vfs.src([themeModule + '/assets/**'], { base: themeModule })\n    .pipe(concat(function (files) {\n      callback(null, files.concat(new File({\n        path: 'index.html',\n        contents: new Buffer(pageTemplate({\n          docs: comments,\n          options: options\n        }), 'utf8')\n      })));\n    }));\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/get_template.js":"'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\n\n/**\n * Get a Handlebars template file out of a theme and compile it into\n * a template function\n *\n * @param {Object} Handlebars handlebars instance\n * @param {string} themeModule base directory of themey\n * @param {string} name template name\n * @returns {Function} template function\n */\nfunction getTemplate(Handlebars, themeModule, name) {\n  try {\n    return Handlebars\n      .compile(fs.readFileSync(path.join(themeModule, name), 'utf8'));\n  } catch (e) {\n    throw new Error('Template file ' + name + ' missing');\n  }\n}\n\nmodule.exports = getTemplate;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/resolve_theme.js":"'use strict';\n\nvar path = require('path'),\n  resolve = require('resolve');\n\n/**\n * Given the name of a theme as a module, return the directory it\n * resides in, or throw an error if it is not found\n * @param {string} [theme='documentation-theme-default'] the module name\n * @throws {Error} if theme is not found\n * @returns {string} directory\n */\nfunction resolveTheme(theme) {\n  var basedir = theme ? process.cwd() : __dirname;\n\n  theme = theme || 'documentation-theme-default';\n\n  try {\n    return path.dirname(resolve.sync(theme, { basedir: basedir }));\n  } catch (e) {\n    throw new Error('Theme ' + theme + ' not found');\n  }\n}\n\nmodule.exports = resolveTheme;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/html_helpers.js":"'use strict';\n\nvar getGlobalExternalLink = require('globals-docs').getDoc,\n  mdast = require('mdast'),\n  html = require('mdast-html'),\n  inlineLex = require('jsdoc-inline-lex');\n\n/**\n * Format a description and target as a Markdown link.\n *\n * @param {string} description the text seen as the link\n * @param {string} href where the link goes\n * @return {string} markdown formatted link\n */\nfunction markdownLink(description, href) {\n  return '[`' + description + '`](' + href + ')';\n}\n\n/**\n * Format link & tutorial tags with simple code inline tags.\n *\n * @param {string} text input - typically a description\n * @returns {string} markdown-friendly output\n * @private\n * @example\n * formatInlineTags('{@link Foo}'); // \"[Foo](#foo)\"\n */\nfunction formatInlineTags(text) {\n  var output = '';\n  var tokens = inlineLex(text);\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].type === 'text') {\n      output += tokens[i].capture[0];\n    } else if (tokens[i].type === 'link') {\n      var parts = tokens[i].capture[1].split(/\\s|\\|/);\n      if (parts.length === 1) {\n        output += markdownLink(tokens[i].capture[1], tokens[i].capture[1]);\n      } else {\n        output += markdownLink(parts.slice(1).join(' '), parts[0]);\n      }\n    } else if (tokens[i].type === 'prefixLink') {\n      output += markdownLink(tokens[i].capture[1], tokens[i].capture[2]);\n    }\n  }\n\n  return output;\n}\n\n/**\n * Link text to this page or to a central resource.\n * @param {Array<string>} paths list of valid namespace paths that are linkable\n * @param {string} text inner text of the link\n * @returns {string} potentially linked HTML\n */\nfunction autolink(paths, text) {\n  if (paths.indexOf(text) !== -1) {\n    return '<a href=\"#' + text + '\">' + text + '</a>';\n  } else if (getGlobalExternalLink(text)) {\n    return '<a href=\"' + getGlobalExternalLink(text) + '\">' + text + '</a>';\n  }\n  return text;\n}\n\n/**\n * Helper used to format JSDoc-style type definitions into HTML.\n *\n * @name formatType\n * @param {Object} type type object in doctrine style\n * @param {Array<string>} paths valid namespace paths that can be linked\n * @returns {string} string\n * @example\n * var x = { type: 'NameExpression', name: 'String' };\n * // in template\n * // {{ type x }}\n * // generates String\n */\nfunction formatType(type, paths) {\n  if (!type) {\n    return '';\n  }\n  function recurse(element) {\n    return formatType(element, paths);\n  }\n  switch (type.type) {\n  case 'NameExpression':\n    return '<code>' + autolink(paths, type.name) + '</code>';\n  case 'UnionType':\n    return type.elements.map(recurse).join(' or ');\n  case 'AllLiteral':\n    return 'Any';\n  case 'RestType':\n    return '...' + formatType(type.expression, paths);\n  case 'OptionalType':\n    return '<code>[' + formatType(type.expression, paths) + ']</code>';\n  case 'TypeApplication':\n    return formatType(type.expression, paths) + '<' +\n      type.applications.map(recurse).join(', ') + '>';\n  case 'UndefinedLiteral':\n    return 'undefined';\n  }\n}\n\n/**\n * Format a parameter name. This is used in formatParameters\n * and just needs to be careful about differentiating optional\n * parameters\n *\n * @param {Object} param a param as a type spec\n * @returns {string} formatted parameter representation.\n */\nfunction formatParameter(param) {\n  return (param.type && param.type.type === 'OptionalType') ?\n    '[' + param.name + ']' : param.name;\n}\n\n/**\n * Format the parameters of a function into a quickly-readable\n * summary that resembles how you would call the function\n * initially.\n *\n * @returns {string} formatted parameters\n */\nfunction formatParameters() {\n  if (!this.params) {\n    return '';\n  }\n  return '(' + this.params.map(function (param) {\n    return formatParameter(param);\n  }).join(', ') + ')';\n}\n\n/**\n * Given a Handlebars instance, register helpers\n *\n * @param {Object} Handlebars template instance\n * @param {Array<string>} paths list of valid namespace paths that are linkable\n * @returns {undefined} invokes side effects on Handlebars\n */\nfunction htmlHelpers(Handlebars, paths) {\n  Handlebars.registerHelper('permalink', function () {\n    return this.path.join('.');\n  });\n\n  Handlebars.registerHelper('autolink', autolink.bind(autolink, paths));\n\n  Handlebars.registerHelper('format_params', formatParameters);\n\n  /**\n   * This helper is exposed in templates as `md` and is useful for showing\n   * Markdown-formatted text as proper HTML.\n   *\n   * @name formatMarkdown\n   * @param {string} string\n   * @returns {string} string\n   * @example\n   * var x = '## foo';\n   * // in template\n   * // {{ md x }}\n   * // generates <h2>foo</h2>\n   */\n  Handlebars.registerHelper('md', function formatMarkdown(string) {\n    return new Handlebars.SafeString(mdast().use(html).process(formatInlineTags(string)));\n  });\n\n  Handlebars.registerHelper('format_type', function (type) {\n    return formatType(type, paths);\n  });\n}\n\nmodule.exports = htmlHelpers;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/output/markdown.js":"'use strict';\n\nvar mdast = require('mdast'),\n  toc = require('mdast-toc'),\n  markdownAST = require('./markdown_ast');\n\n/**\n * Formats documentation as\n * [Markdown](http://daringfireball.net/projects/markdown/).\n *\n * @param {Array<Object>} comments parsed comments\n * @param {Object} opts Options that can customize the output\n * @param {Function} callback called with null, string\n * @name markdown\n * @return {undefined} calls callback\n */\nmodule.exports = function (comments, opts, callback) {\n  var processor = mdast().use(toc);\n  markdownAST(comments, opts, function (err, ast) {\n    var processedAST = processor.run(ast);\n    return callback(null, processor.stringify(processedAST));\n  });\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/output/markdown_ast.js":"var mdast = require('mdast'),\n  u = require('unist-builder'),\n  formatType = require('../markdown_format_type'),\n  formatInlineTags = require('../format_inline_tags');\n\n/**\n * Given a hierarchy-nested set of comments, generate an mdast-compatible\n * Abstract Syntax Tree usable for generating Markdown output\n *\n * @param {Array<Object>} comments nested comment\n * @param {Object} opts currently none accepted\n * @param {Function} callback called with AST\n * @returns {undefined} calls callback\n */\nfunction commentsToAST(comments, opts, callback) {\n\n  /**\n   * Generate an AST chunk for a comment at a given depth: this is\n   * split from the main function to handle hierarchially nested comments\n   *\n   * @param {number} depth nesting of the comment, starting at 1\n   * @param {Object} comment a single comment\n   * @returns {Object} mdast-compatible AST\n   */\n  function generate(depth, comment) {\n\n    function paramList(params) {\n      return u('list', { ordered: false }, params.map(function (param) {\n        return u('listItem', [\n          u('paragraph', [\n            u('inlineCode', param.name),\n            u('text', ' '),\n            !!param.type && u('strong', [u('text', formatType(param.type))]),\n            u('text', ' ')\n          ].concat(mdast.parse(formatInlineTags(param.description)).children)\n          .concat([\n            !!param.default && u('paragraph', [\n              u('text', ' (optional, default '),\n              u('inlineCode', param.default),\n              u('text', ')')\n            ])\n          ]).filter(Boolean))\n        ].concat(param.properties && paramList(param.properties))\n        .filter(Boolean));\n      }));\n    }\n\n    function paramSection(comment) {\n      return !!comment.params && [\n        u('strong', [u('text', 'Parameters')]),\n        paramList(comment.params)\n      ];\n    }\n\n    function propertySection(comment) {\n      return !!comment.properties && [\n        u('strong', [u('text', 'Properties')]),\n        propertyList(comment.properties)\n      ];\n    }\n\n    function propertyList(properties) {\n      return u('list', { ordered: false },\n        properties.map(function (property) {\n          return u('listItem', [\n            u('paragraph', [\n              u('inlineCode', property.name),\n              u('text', ' '),\n              u('strong', [u('text', formatType(property.type))]),\n              u('text', ' ')\n            ]\n            .concat(mdast.parse(formatInlineTags(property.description)).children)\n            .filter(Boolean)),\n            property.properties && propertyList(property.properties)\n          ].filter(Boolean))\n        }));\n    }\n\n    function examplesSection(comment) {\n      return !!comment.examples && [u('strong', [u('text', 'Examples')])]\n        .concat(comment.examples.map(function (example) {\n          return u('code', { lang: 'javascript' }, example);\n        }));\n    }\n\n    function returnsSection(comment) {\n      return !!comment.returns && comment.returns.map(function (returns) {\n        return u('paragraph', [\n          u('text', 'Returns '),\n          u('strong', [u('text', formatType(returns.type))]),\n          u('text', ' ')\n        ].concat(mdast.parse(formatInlineTags(returns.description)).children))\n      });\n    }\n\n    function githubLink(comment) {\n      return comment.context.github && u('paragraph', [\n        u('link', {\n          title: 'Source code on GitHub',\n          href: comment.context.github\n        }, [u('text', comment.context.path + ':' +\n          comment.context.loc.start.line + '-' +\n          comment.context.loc.end.line)])\n      ]);\n    }\n\n    return [u('heading', { depth: depth }, [u('text', comment.name)])]\n    .concat(githubLink(comment))\n    .concat(mdast.parse(formatInlineTags(comment.description)).children)\n    .concat(paramSection(comment))\n    .concat(propertySection(comment))\n    .concat(examplesSection(comment))\n    .concat(returnsSection(comment))\n    .concat(!!comment.members.instance.length &&\n      comment.members.instance.reduce(function (memo, child) {\n        return memo.concat(generate(depth + 1, child));\n      }, []))\n    .concat(!!comment.members.static.length &&\n      comment.members.static.reduce(function (memo, child) {\n        return memo.concat(generate(depth + 1, child));\n      }, []))\n    .filter(Boolean);\n  }\n\n  return callback(null, u('root', comments.reduce(function (memo, comment) {\n    return memo.concat(generate(1, comment));\n  }, [])));\n}\n\nmodule.exports = commentsToAST;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/markdown_format_type.js":"function formatType(type) {\n  if (!type) {\n    return '';\n  }\n  switch (type.type) {\n  case 'NameExpression':\n    return type.name;\n  case 'UnionType':\n    return type.elements.map(function (element) {\n      return formatType(element);\n    }).join(' or ');\n  case 'AllLiteral':\n    return 'Any';\n  case 'OptionalType':\n    return '[' + formatType(type.expression) + ']';\n  case 'RestType':\n    return '...' + formatType(type.expression);\n  case 'TypeApplication':\n    return formatType(type.expression) + '&lt;' +\n      type.applications.map(function (application) {\n        return formatType(application);\n      }).join(', ') + '&gt;';\n  case 'UndefinedLiteral':\n    return 'undefined';\n  }\n}\n\nmodule.exports = formatType;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/format_inline_tags.js":"var inlineLex = require('jsdoc-inline-lex');\n\n/**\n * Format link & tutorial tags with simple code inline tags.\n *\n * @param {string} text input - typically a description\n * @returns {string} markdown-friendly output\n * @private\n * @example\n * formatInlineTags('{@link Foo}'); // \"`Foo`\"\n */\nfunction formatInlineTags(text) {\n  var output = '';\n  var tokens = inlineLex(text);\n\n  for (var i = 0; i < tokens.length; i++) {\n    if (tokens[i].type === 'text') {\n      output += tokens[i].capture[0];\n    } else {\n      output += '`' + tokens[i].capture[1] + '`';\n    }\n  }\n\n  return output;\n}\n\nmodule.exports = formatInlineTags;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/output/json.js":"'use strict';\n\nvar walk = require('../walk');\n\n/**\n * Formats documentation as a JSON string.\n *\n * @param {Array<Object>} comments parsed comments\n * @param {Object} opts Options that can customize the output\n * @param {Function} callback called with null, string\n * @name json\n * @return {undefined} calls callback\n */\nmodule.exports = function (comments, opts, callback) {\n\n  walk(comments, function (comment) {\n    delete comment.errors;\n  });\n\n  return callback(null, JSON.stringify(comments, null, 2));\n};\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/bin/documentation.js":"#!/usr/bin/env node\n\n/* eslint no-console: 0 */\n\n'use strict';\n\nvar documentation = require('../'),\n  streamArray = require('stream-array'),\n  fs = require('fs'),\n  vfs = require('vinyl-fs'),\n  lint = require('../lib/lint'),\n  args = require('../lib/args.js');\n\nvar parsedArgs = args(process.argv.slice(2)),\n  formatterOptions = parsedArgs.formatterOptions,\n  outputLocation = parsedArgs.output,\n  formatter = documentation.formats[parsedArgs.formatter];\n\ndocumentation(parsedArgs.inputs, parsedArgs.options, function (err, comments) {\n  if (err) {\n    throw err;\n  }\n\n  if (parsedArgs.options.lint) {\n    var lintOutput = lint.format(comments);\n    if (lintOutput) {\n      console.log(lintOutput);\n      process.exit(1);\n    } else {\n      process.exit(0);\n    }\n  }\n\n  formatter(comments, formatterOptions, function (err, output) {\n    if (outputLocation !== 'stdout') {\n      if (parsedArgs.formatter === 'html') {\n        streamArray(output).pipe(vfs.dest(outputLocation));\n      } else {\n        fs.writeFileSync(outputLocation, output);\n      }\n    } else {\n      process.stdout.write(output);\n    }\n  });\n});\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/args.js":"var path = require('path'),\n  yargs = require('yargs'),\n  loadConfig = require('../lib/load_config.js');\n\nfunction parse(args) {\n  // reset() needs to be called at parse time because the yargs module uses an\n  // internal global variable to hold option state\n  return yargs.reset()\n  .usage('Usage: $0 <command> [options]')\n\n  .option('f', {\n    alias: 'format',\n    default: 'json',\n    choices: ['json', 'md', 'html']\n  })\n\n  .option('lint', {\n    describe: 'check output for common style and uniformity mistakes',\n    type: 'boolean'\n  })\n\n  .describe('t', 'specify a theme: this must be a valid theme module')\n  .alias('t', 'theme')\n\n  .boolean('p')\n  .describe('p', 'generate documentation tagged as private')\n  .alias('p', 'private')\n\n  .version(function () {\n    return require('../package').version;\n  })\n\n  .describe('name', 'project name. by default, inferred from package.json')\n  .describe('project-version', 'project version. by default, inferred from package.json')\n\n  .option('shallow', {\n    describe: 'shallow mode turns off dependency resolution, ' +\n    'only processing the specified files (or the main script specified in package.json)',\n    default: false,\n    type: 'boolean'\n  })\n\n  .boolean('polyglot')\n  .describe('polyglot', 'polyglot mode turns off dependency resolution and ' +\n            'enables multi-language support. use this to document c++')\n\n  .boolean('g')\n  .describe('g', 'infer links to github in documentation')\n  .alias('g', 'github')\n\n  .option('o', {\n    describe: 'output location. omit for stdout, otherwise is a filename ' +\n      'for single-file outputs and a directory name for multi-file outputs like html',\n    alias: 'output',\n    default: 'stdout'\n  })\n\n  .describe('c', 'configuration file. an array defining explicit sort order')\n  .alias('c', 'config')\n\n  .help('h')\n  .alias('h', 'help')\n\n  .example('$0 foo.js', 'parse documentation in a given file')\n\n  .parse(args)\n\n}\n/**\n * Parse and validate command-line options for documentation.\n * @param {Array} args The array of arguments to parse; e.g. process.argv.slice(2).\n * @return {object} {inputs, options, formatter, formatterOptions, output}\n * @private\n */\nmodule.exports = function (args) {\n  var argv = parse(args);\n\n  var inputs,\n    name = argv.name,\n    version = argv['project-version'],\n    transform;\n\n  if (argv._.length > 0) {\n    inputs = argv._;\n  } else {\n    try {\n      var p = require(path.resolve('package.json'));\n      inputs = [p.main || 'index.js'];\n      name = name || p.name;\n      version = version || p.version;\n      if (p.browserify && p.browserify.transform) {\n        transform = p.browserify.transform;\n      }\n    } catch (e) {\n      yargs.showHelp();\n      throw new Error('documentation was given no files and was not run in a module directory');\n    }\n  }\n\n  if (argv.f === 'html' && argv.o === 'stdout') {\n    yargs.showHelp();\n    throw new Error('The HTML output mode requires a destination directory set with -o');\n  }\n\n  var config = {};\n\n  if (argv.config) {\n    config = loadConfig(argv.config);\n  }\n\n  return {\n    inputs: inputs,\n    options: {\n      private: argv.private,\n      transform: transform,\n      lint: argv.lint,\n      github: argv.github,\n      polyglot: argv.polyglot,\n      order: config.order || [],\n      shallow: argv.shallow\n    },\n    formatter: argv.f,\n    formatterOptions: {\n      name: name,\n      version: version,\n      theme: argv.theme\n    },\n    output: argv.o\n  }\n}\n\n\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/lib/load_config.js":"'use strict';\n\nvar yaml = require('js-yaml'),\n  fs = require('fs'),\n  path = require('path'),\n  stripComments = require('strip-json-comments');\n\n/**\n * Try to load a configuration file: since this is configuration, we're\n * lenient with respect to its structure. It can be JSON or YAML,\n * and can contain comments, unlike normal JSON.\n *\n * @param {string} filePath the user-provided path to configuration\n * @returns {Object} configuration, if it can be parsed\n * @throws {Error} if the file cannot be read.\n */\nfunction loadConfig(filePath) {\n  try {\n    return yaml.safeLoad(\n      stripComments(\n        fs.readFileSync(\n          path.resolve(process.cwd(), filePath), 'utf8')));\n  } catch (e) {\n    e.message = 'Cannot read config file: ' +\n      filePath +\n      '\\nError: ' +\n      e.message;\n    throw e;\n  }\n}\n\nmodule.exports = loadConfig;\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/out/scripts/linenumber.js":"/*global document */\n(function() {\n    var source = document.getElementsByClassName('prettyprint source linenums');\n    var i = 0;\n    var lineNumber = 0;\n    var lineId;\n    var lines;\n    var totalLines;\n    var anchorHash;\n\n    if (source && source[0]) {\n        anchorHash = document.location.hash.substring(1);\n        lines = source[0].getElementsByTagName('li');\n        totalLines = lines.length;\n\n        for (; i < totalLines; i++) {\n            lineNumber++;\n            lineId = 'line' + lineNumber;\n            lines[i].id = lineId;\n            if (lineId === anchorHash) {\n                lines[i].className += ' selected';\n            }\n        }\n    }\n})();\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/out/scripts/prettify/lang-css.js":"PR.registerLangHandler(PR.createSimpleLexer([[\"pln\",/^[\\t\\n\\f\\r ]+/,null,\" \\t\\r\\n\f\"]],[[\"str\",/^\"(?:[^\\n\\f\\r\"\\\\]|\\\\(?:\\r\\n?|\\n|\\f)|\\\\[\\S\\s])*\"/,null],[\"str\",/^'(?:[^\\n\\f\\r'\\\\]|\\\\(?:\\r\\n?|\\n|\\f)|\\\\[\\S\\s])*'/,null],[\"lang-css-str\",/^url\\(([^\"')]*)\\)/i],[\"kwd\",/^(?:url|rgb|!important|@import|@page|@media|@charset|inherit)(?=[^\\w-]|$)/i,null],[\"lang-css-kw\",/^(-?(?:[_a-z]|\\\\[\\da-f]+ ?)(?:[\\w-]|\\\\\\\\[\\da-f]+ ?)*)\\s*:/i],[\"com\",/^\\/\\*[^*]*\\*+(?:[^*/][^*]*\\*+)*\\//],[\"com\",\n/^(?:<\\!--|--\\>)/],[\"lit\",/^(?:\\d+|\\d*\\.\\d+)(?:%|[a-z]+)?/i],[\"lit\",/^#[\\da-f]{3,6}/i],[\"pln\",/^-?(?:[_a-z]|\\\\[\\da-f]+ ?)(?:[\\w-]|\\\\\\\\[\\da-f]+ ?)*/i],[\"pun\",/^[^\\s\\w\"']+/]]),[\"css\"]);PR.registerLangHandler(PR.createSimpleLexer([],[[\"kwd\",/^-?(?:[_a-z]|\\\\[\\da-f]+ ?)(?:[\\w-]|\\\\\\\\[\\da-f]+ ?)*/i]]),[\"css-kw\"]);PR.registerLangHandler(PR.createSimpleLexer([],[[\"str\",/^[^\"')]+/]]),[\"css-str\"]);\n","/home/travis/build/npmtest/node-npmtest-documentation/node_modules/documentation/out/scripts/prettify/prettify.js":"var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;\n(function(){function L(a){function m(a){var f=a.charCodeAt(0);if(f!==92)return f;var b=a.charAt(1);return(f=r[b])?f:\"0\"<=b&&b<=\"7\"?parseInt(a.substring(1),8):b===\"u\"||b===\"x\"?parseInt(a.substring(2),16):a.charCodeAt(1)}function e(a){if(a<32)return(a<16?\"\\\\x0\":\"\\\\x\")+a.toString(16);a=String.fromCharCode(a);if(a===\"\\\\\"||a===\"-\"||a===\"[\"||a===\"]\")a=\"\\\\\"+a;return a}function h(a){for(var f=a.substring(1,a.length-1).match(/\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\[0-3][0-7]{0,2}|\\\\[0-7]{1,2}|\\\\[\\S\\s]|[^\\\\]/g),a=\n[],b=[],o=f[0]===\"^\",c=o?1:0,i=f.length;c<i;++c){var j=f[c];if(/\\\\[bdsw]/i.test(j))a.push(j);else{var j=m(j),d;c+2<i&&\"-\"===f[c+1]?(d=m(f[c+2]),c+=2):d=j;b.push([j,d]);d<65||j>122||(d<65||j>90||b.push([Math.max(65,j)|32,Math.min(d,90)|32]),d<97||j>122||b.push([Math.max(97,j)&-33,Math.min(d,122)&-33]))}}b.sort(function(a,f){return a[0]-f[0]||f[1]-a[1]});f=[];j=[NaN,NaN];for(c=0;c<b.length;++c)i=b[c],i[0]<=j[1]+1?j[1]=Math.max(j[1],i[1]):f.push(j=i);b=[\"[\"];o&&b.push(\"^\");b.push.apply(b,a);for(c=0;c<\nf.length;++c)i=f[c],b.push(e(i[0])),i[1]>i[0]&&(i[1]+1>i[0]&&b.push(\"-\"),b.push(e(i[1])));b.push(\"]\");return b.join(\"\")}function y(a){for(var f=a.source.match(/\\[(?:[^\\\\\\]]|\\\\[\\S\\s])*]|\\\\u[\\dA-Fa-f]{4}|\\\\x[\\dA-Fa-f]{2}|\\\\\\d+|\\\\[^\\dux]|\\(\\?[!:=]|[()^]|[^()[\\\\^]+/g),b=f.length,d=[],c=0,i=0;c<b;++c){var j=f[c];j===\"(\"?++i:\"\\\\\"===j.charAt(0)&&(j=+j.substring(1))&&j<=i&&(d[j]=-1)}for(c=1;c<d.length;++c)-1===d[c]&&(d[c]=++t);for(i=c=0;c<b;++c)j=f[c],j===\"(\"?(++i,d[i]===void 0&&(f[c]=\"(?:\")):\"\\\\\"===j.charAt(0)&&\n(j=+j.substring(1))&&j<=i&&(f[c]=\"\\\\\"+d[i]);for(i=c=0;c<b;++c)\"^\"===f[c]&&\"^\"!==f[c+1]&&(f[c]=\"\");if(a.ignoreCase&&s)for(c=0;c<b;++c)j=f[c],a=j.charAt(0),j.length>=2&&a===\"[\"?f[c]=h(j):a!==\"\\\\\"&&(f[c]=j.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return\"[\"+String.fromCharCode(a&-33,a|32)+\"]\"}));return f.join(\"\")}for(var t=0,s=!1,l=!1,p=0,d=a.length;p<d;++p){var g=a[p];if(g.ignoreCase)l=!0;else if(/[a-z]/i.test(g.source.replace(/\\\\u[\\da-f]{4}|\\\\x[\\da-f]{2}|\\\\[^UXux]/gi,\"\"))){s=!0;l=!1;break}}for(var r=\n{b:8,t:9,n:10,v:11,f:12,r:13},n=[],p=0,d=a.length;p<d;++p){g=a[p];if(g.global||g.multiline)throw Error(\"\"+g);n.push(\"(?:\"+y(g)+\")\")}return RegExp(n.join(\"|\"),l?\"gi\":\"g\")}function M(a){function m(a){switch(a.nodeType){case 1:if(e.test(a.className))break;for(var g=a.firstChild;g;g=g.nextSibling)m(g);g=a.nodeName;if(\"BR\"===g||\"LI\"===g)h[s]=\"\\n\",t[s<<1]=y++,t[s++<<1|1]=a;break;case 3:case 4:g=a.nodeValue,g.length&&(g=p?g.replace(/\\r\\n?/g,\"\\n\"):g.replace(/[\\t\\n\\r ]+/g,\" \"),h[s]=g,t[s<<1]=y,y+=g.length,\nt[s++<<1|1]=a)}}var e=/(?:^|\\s)nocode(?:\\s|$)/,h=[],y=0,t=[],s=0,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=document.defaultView.getComputedStyle(a,q).getPropertyValue(\"white-space\"));var p=l&&\"pre\"===l.substring(0,3);m(a);return{a:h.join(\"\").replace(/\\n$/,\"\"),c:t}}function B(a,m,e,h){m&&(a={a:m,d:a},e(a),h.push.apply(h,a.e))}function x(a,m){function e(a){for(var l=a.d,p=[l,\"pln\"],d=0,g=a.a.match(y)||[],r={},n=0,z=g.length;n<z;++n){var f=g[n],b=r[f],o=void 0,c;if(typeof b===\n\"string\")c=!1;else{var i=h[f.charAt(0)];if(i)o=f.match(i[1]),b=i[0];else{for(c=0;c<t;++c)if(i=m[c],o=f.match(i[1])){b=i[0];break}o||(b=\"pln\")}if((c=b.length>=5&&\"lang-\"===b.substring(0,5))&&!(o&&typeof o[1]===\"string\"))c=!1,b=\"src\";c||(r[f]=b)}i=d;d+=f.length;if(c){c=o[1];var j=f.indexOf(c),k=j+c.length;o[2]&&(k=f.length-o[2].length,j=k-c.length);b=b.substring(5);B(l+i,f.substring(0,j),e,p);B(l+i+j,c,C(b,c),p);B(l+i+k,f.substring(k),e,p)}else p.push(l+i,b)}a.e=p}var h={},y;(function(){for(var e=a.concat(m),\nl=[],p={},d=0,g=e.length;d<g;++d){var r=e[d],n=r[3];if(n)for(var k=n.length;--k>=0;)h[n.charAt(k)]=r;r=r[1];n=\"\"+r;p.hasOwnProperty(n)||(l.push(r),p[n]=q)}l.push(/[\\S\\s]/);y=L(l)})();var t=m.length;return e}function u(a){var m=[],e=[];a.tripleQuotedStrings?m.push([\"str\",/^(?:'''(?:[^'\\\\]|\\\\[\\S\\s]|''?(?=[^']))*(?:'''|$)|\"\"\"(?:[^\"\\\\]|\\\\[\\S\\s]|\"\"?(?=[^\"]))*(?:\"\"\"|$)|'(?:[^'\\\\]|\\\\[\\S\\s])*(?:'|$)|\"(?:[^\"\\\\]|\\\\[\\S\\s])*(?:\"|$))/,q,\"'\\\"\"]):a.multiLineStrings?m.push([\"str\",/^(?:'(?:[^'\\\\]|\\\\[\\S\\s])*(?:'|$)|\"(?:[^\"\\\\]|\\\\[\\S\\s])*(?:\"|$)|`(?:[^\\\\`]|\\\\[\\S\\s])*(?:`|$))/,\nq,\"'\\\"`\"]):m.push([\"str\",/^(?:'(?:[^\\n\\r'\\\\]|\\\\.)*(?:'|$)|\"(?:[^\\n\\r\"\\\\]|\\\\.)*(?:\"|$))/,q,\"\\\"'\"]);a.verbatimStrings&&e.push([\"str\",/^@\"(?:[^\"]|\"\")*(?:\"|$)/,q]);var h=a.hashComments;h&&(a.cStyleComments?(h>1?m.push([\"com\",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,\"#\"]):m.push([\"com\",/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\\b|[^\\n\\r]*)/,q,\"#\"]),e.push([\"str\",/^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h|[a-z]\\w*)>/,q])):m.push([\"com\",/^#[^\\n\\r]*/,\nq,\"#\"]));a.cStyleComments&&(e.push([\"com\",/^\\/\\/[^\\n\\r]*/,q]),e.push([\"com\",/^\\/\\*[\\S\\s]*?(?:\\*\\/|$)/,q]));a.regexLiterals&&e.push([\"lang-regex\",/^(?:^^\\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\\(|\\*|\\*=|\\+=|,|-=|->|\\/|\\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\\^=|\\^\\^|\\^\\^=|{|\\||\\|=|\\|\\||\\|\\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\s*(\\/(?=[^*/])(?:[^/[\\\\]|\\\\[\\S\\s]|\\[(?:[^\\\\\\]]|\\\\[\\S\\s])*(?:]|$))+\\/)/]);(h=a.types)&&e.push([\"typ\",h]);a=(\"\"+a.keywords).replace(/^ | $/g,\n\"\");a.length&&e.push([\"kwd\",RegExp(\"^(?:\"+a.replace(/[\\s,]+/g,\"|\")+\")\\\\b\"),q]);m.push([\"pln\",/^\\s+/,q,\" \\r\\n\\t\\xa0\"]);e.push([\"lit\",/^@[$_a-z][\\w$@]*/i,q],[\"typ\",/^(?:[@_]?[A-Z]+[a-z][\\w$@]*|\\w+_t\\b)/,q],[\"pln\",/^[$_a-z][\\w$@]*/i,q],[\"lit\",/^(?:0x[\\da-f]+|(?:\\d(?:_\\d+)*\\d*(?:\\.\\d*)?|\\.\\d\\+)(?:e[+-]?\\d+)?)[a-z]*/i,q,\"0123456789\"],[\"pln\",/^\\\\[\\S\\s]?/,q],[\"pun\",/^.[^\\s\\w\"-$'./@\\\\`]*/,q]);return x(m,e)}function D(a,m){function e(a){switch(a.nodeType){case 1:if(k.test(a.className))break;if(\"BR\"===a.nodeName)h(a),\na.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)e(a);break;case 3:case 4:if(p){var b=a.nodeValue,d=b.match(t);if(d){var c=b.substring(0,d.index);a.nodeValue=c;(b=b.substring(d.index+d[0].length))&&a.parentNode.insertBefore(s.createTextNode(b),a.nextSibling);h(a);c||a.parentNode.removeChild(a)}}}}function h(a){function b(a,d){var e=d?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),g=a.nextSibling;f.appendChild(e);for(var h=g;h;h=g)g=h.nextSibling,f.appendChild(h)}return e}\nfor(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),e;(e=a.parentNode)&&e.nodeType===1;)a=e;d.push(a)}var k=/(?:^|\\s)nocode(?:\\s|$)/,t=/\\r\\n?|\\n/,s=a.ownerDocument,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=s.defaultView.getComputedStyle(a,q).getPropertyValue(\"white-space\"));var p=l&&\"pre\"===l.substring(0,3);for(l=s.createElement(\"LI\");a.firstChild;)l.appendChild(a.firstChild);for(var d=[l],g=0;g<d.length;++g)e(d[g]);m===(m|0)&&d[0].setAttribute(\"value\",\nm);var r=s.createElement(\"OL\");r.className=\"linenums\";for(var n=Math.max(0,m-1|0)||0,g=0,z=d.length;g<z;++g)l=d[g],l.className=\"L\"+(g+n)%10,l.firstChild||l.appendChild(s.createTextNode(\"\\xa0\")),r.appendChild(l);a.appendChild(r)}function k(a,m){for(var e=m.length;--e>=0;){var h=m[e];A.hasOwnProperty(h)?window.console&&console.warn(\"cannot override language handler %s\",h):A[h]=a}}function C(a,m){if(!a||!A.hasOwnProperty(a))a=/^\\s*</.test(m)?\"default-markup\":\"default-code\";return A[a]}function E(a){var m=\na.g;try{var e=M(a.h),h=e.a;a.a=h;a.c=e.c;a.d=0;C(m,h)(a);var k=/\\bMSIE\\b/.test(navigator.userAgent),m=/\\n/g,t=a.a,s=t.length,e=0,l=a.c,p=l.length,h=0,d=a.e,g=d.length,a=0;d[g]=s;var r,n;for(n=r=0;n<g;)d[n]!==d[n+2]?(d[r++]=d[n++],d[r++]=d[n++]):n+=2;g=r;for(n=r=0;n<g;){for(var z=d[n],f=d[n+1],b=n+2;b+2<=g&&d[b+1]===f;)b+=2;d[r++]=z;d[r++]=f;n=b}for(d.length=r;h<p;){var o=l[h+2]||s,c=d[a+2]||s,b=Math.min(o,c),i=l[h+1],j;if(i.nodeType!==1&&(j=t.substring(e,b))){k&&(j=j.replace(m,\"\\r\"));i.nodeValue=\nj;var u=i.ownerDocument,v=u.createElement(\"SPAN\");v.className=d[a+1];var x=i.parentNode;x.replaceChild(v,i);v.appendChild(i);e<o&&(l[h+1]=i=u.createTextNode(t.substring(b,o)),x.insertBefore(i,v.nextSibling))}e=b;e>=o&&(h+=2);e>=c&&(a+=2)}}catch(w){\"console\"in window&&console.log(w&&w.stack?w.stack:w)}}var v=[\"break,continue,do,else,for,if,return,while\"],w=[[v,\"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"],\n\"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof\"],F=[w,\"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where\"],G=[w,\"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient\"],\nH=[G,\"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var\"],w=[w,\"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN\"],I=[v,\"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None\"],\nJ=[v,\"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END\"],v=[v,\"case,done,elif,esac,eval,fi,function,in,local,set,then,until\"],K=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)/,N=/\\S/,O=u({keywords:[F,H,w,\"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END\"+\nI,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,[\"default-code\"]);k(x([],[[\"pln\",/^[^<?]+/],[\"dec\",/^<!\\w[^>]*(?:>|$)/],[\"com\",/^<\\!--[\\S\\s]*?(?:--\\>|$)/],[\"lang-\",/^<\\?([\\S\\s]+?)(?:\\?>|$)/],[\"lang-\",/^<%([\\S\\s]+?)(?:%>|$)/],[\"pun\",/^(?:<[%?]|[%?]>)/],[\"lang-\",/^<xmp\\b[^>]*>([\\S\\s]+?)<\\/xmp\\b[^>]*>/i],[\"lang-js\",/^<script\\b[^>]*>([\\S\\s]*?)(<\\/script\\b[^>]*>)/i],[\"lang-css\",/^<style\\b[^>]*>([\\S\\s]*?)(<\\/style\\b[^>]*>)/i],[\"lang-in.tag\",/^(<\\/?[a-z][^<>]*>)/i]]),\n[\"default-markup\",\"htm\",\"html\",\"mxml\",\"xhtml\",\"xml\",\"xsl\"]);k(x([[\"pln\",/^\\s+/,q,\" \\t\\r\\n\"],[\"atv\",/^(?:\"[^\"]*\"?|'[^']*'?)/,q,\"\\\"'\"]],[[\"tag\",/^^<\\/?[a-z](?:[\\w-.:]*\\w)?|\\/?>$/i],[\"atn\",/^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],[\"lang-uq.val\",/^=\\s*([^\\s\"'>]*(?:[^\\s\"'/>]|\\/(?=\\s)))/],[\"pun\",/^[/<->]+/],[\"lang-js\",/^on\\w+\\s*=\\s*\"([^\"]+)\"/i],[\"lang-js\",/^on\\w+\\s*=\\s*'([^']+)'/i],[\"lang-js\",/^on\\w+\\s*=\\s*([^\\s\"'>]+)/i],[\"lang-css\",/^style\\s*=\\s*\"([^\"]+)\"/i],[\"lang-css\",/^style\\s*=\\s*'([^']+)'/i],[\"lang-css\",\n/^style\\s*=\\s*([^\\s\"'>]+)/i]]),[\"in.tag\"]);k(x([],[[\"atv\",/^[\\S\\s]+/]]),[\"uq.val\"]);k(u({keywords:F,hashComments:!0,cStyleComments:!0,types:K}),[\"c\",\"cc\",\"cpp\",\"cxx\",\"cyc\",\"m\"]);k(u({keywords:\"null,true,false\"}),[\"json\"]);k(u({keywords:H,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:K}),[\"cs\"]);k(u({keywords:G,cStyleComments:!0}),[\"java\"]);k(u({keywords:v,hashComments:!0,multiLineStrings:!0}),[\"bsh\",\"csh\",\"sh\"]);k(u({keywords:I,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),\n[\"cv\",\"py\"]);k(u({keywords:\"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END\",hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),[\"perl\",\"pl\",\"pm\"]);k(u({keywords:J,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),[\"rb\"]);k(u({keywords:w,cStyleComments:!0,regexLiterals:!0}),[\"js\"]);k(u({keywords:\"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes\",\nhashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),[\"coffee\"]);k(x([],[[\"str\",/^[\\S\\s]+/]]),[\"regex\"]);window.prettyPrintOne=function(a,m,e){var h=document.createElement(\"PRE\");h.innerHTML=a;e&&D(h,e);E({g:m,i:e,h:h});return h.innerHTML};window.prettyPrint=function(a){function m(){for(var e=window.PR_SHOULD_USE_CONTINUATION?l.now()+250:Infinity;p<h.length&&l.now()<e;p++){var n=h[p],k=n.className;if(k.indexOf(\"prettyprint\")>=0){var k=k.match(g),f,b;if(b=\n!k){b=n;for(var o=void 0,c=b.firstChild;c;c=c.nextSibling)var i=c.nodeType,o=i===1?o?b:c:i===3?N.test(c.nodeValue)?b:o:o;b=(f=o===b?void 0:o)&&\"CODE\"===f.tagName}b&&(k=f.className.match(g));k&&(k=k[1]);b=!1;for(o=n.parentNode;o;o=o.parentNode)if((o.tagName===\"pre\"||o.tagName===\"code\"||o.tagName===\"xmp\")&&o.className&&o.className.indexOf(\"prettyprint\")>=0){b=!0;break}b||((b=(b=n.className.match(/\\blinenums\\b(?::(\\d+))?/))?b[1]&&b[1].length?+b[1]:!0:!1)&&D(n,b),d={g:k,h:n,i:b},E(d))}}p<h.length?setTimeout(m,\n250):a&&a()}for(var e=[document.getElementsByTagName(\"pre\"),document.getElementsByTagName(\"code\"),document.getElementsByTagName(\"xmp\")],h=[],k=0;k<e.length;++k)for(var t=0,s=e[k].length;t<s;++t)h.push(e[k][t]);var e=q,l=Date;l.now||(l={now:function(){return+new Date}});var p=0,d,g=/\\blang(?:uage)?-([\\w.]+)(?!\\S)/;m()};window.PR={createSimpleLexer:x,registerLangHandler:k,sourceDecorator:u,PR_ATTRIB_NAME:\"atn\",PR_ATTRIB_VALUE:\"atv\",PR_COMMENT:\"com\",PR_DECLARATION:\"dec\",PR_KEYWORD:\"kwd\",PR_LITERAL:\"lit\",\nPR_NOCODE:\"nocode\",PR_PLAIN:\"pln\",PR_PUNCTUATION:\"pun\",PR_SOURCE:\"src\",PR_STRING:\"str\",PR_TAG:\"tag\",PR_TYPE:\"typ\"}})();\n"}